FIRST EXERCISE:
answer every question, but clearly the theory must be known...

From now on use 3ps as thermalization time, it is reasonable for our results ---> for any calculation!!!
For now, we sould be able to do the first 2 points

1) no junction, the code works if you satisfy the energy criterion. Test different timesteps and build your curve
Then find the optimal time step, the plot must be resonable. The timestep must have a 1 fs precision. Instead of doing
sims of same duration, do sims with 5000 timesteps.
Repeat with T=500 K and show that whatever small is the timestep, we get a significant energy fluctuation

2) Activate the polynomial junction, repeat with 50 K (this is a sanity check). Then proceed finding the optimal dt
for different temperatures. Intuitively, higher T means shorter dt.
Final goal: show and test that the polynomial junction is essential!

NOTE: you can work at home, cause next week there will not be lectures

3) Not yet implemented, thus you cannot do it. But you can see what we'll do, thus plan your code accordingly.
Given the 4 temperatures (thus the 4 sims), you have to run them until 10ps. Once done, analyze T, <T> and sigma(T) and
check if the thermalization does occur (given we operate at the minimum energy configuration, T should go towards T_init/2).
Thus prepare the outputs of task 1 and 2, so that you can test your sim with/without the steepest descent implemented. Clearly,
you can look at Ovito and watch the motion of atoms near the edge and in the "bulk" to get a grasp of what is happening.
Therefore, output the T in task 1 and task 2 too.

NOTE: if rp > rc, then your code will run without the polynomial junction. Note that at low T the presence and the absence
of the junction is not important (atoms do not vibrate strong enough to enter the range of the junction), thus the results 
should be compatible.

MEMO: for 1fs everything works, clearly it's not the best timestep

HOW TO SPEED UP YOUR CODE
- use numpy routines instead of several for cycles
- use numba ---> it compiles portions of your code, thus it runs faster because he's not interpreting all over again.
  To use it, just add the decorator @jit, which compile the function. You can speed up any functions that has
  a repeating operation. The professor thinks the bottleneck is the Verlet function. So start speeding it up first

NOTE: look at there
https://stackoverflow.com/questions/57001070/numpy-zeros-in-numba-function-is-not-working-when-multi-dimensional-shape-is-a-l



---------------------------------------- NOTES ----------------------------------------  

Found timesteps with junction:

- 50 K: 19 fs (20 fs has d(E) ~ 9.5e-6)
- 500 K: 5 fs (6 fs has d(E) ~ 8.9e-6)
- 1000 K: 3 fs (4 fs has d(E) ~ 7.9e-6)
- 2000 K: 2 fs (3 fs has d(E) ~ 9.6e-6)

LIST OF THINGS TO CHANGE:
- True or False for the junction
- timestep size (i.e. dt)
- name of the output folder

Folder name "noPOLY_50K_25fs_5000iter" means:
- do not use the polynomial junction
- initial temperature of 50 K
- size of the timestep set to 25 fs
- do 5000 iterations

Structure of "1_results_noPOLY_50K.txt":
- 0 column: simulation's timestep dt in fs
- 1 column: <E> in eV
- 2 column: sigma(E) / <E>
- 3 column: <T> in K
- 4 column: sigma(T) / <T>

Simulations runned:

1, 5, 10, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25

noPOLY_50K_1fs_5000iter 
noPOLY_50K_5fs_5000iter 
noPOLY_50K_10fs_5000iter 
noPOLY_50K_15fs_5000iter 
noPOLY_50K_16fs_5000iter 
noPOLY_50K_17fs_5000iter 
noPOLY_50K_18fs_5000iter 
noPOLY_50K_19fs_5000iter 
noPOLY_50K_20fs_5000iter 
noPOLY_50K_21fs_5000iter 
noPOLY_50K_22fs_5000iter 
noPOLY_50K_23fs_5000iter 
noPOLY_50K_24fs_5000iter 
noPOLY_50K_25fs_5000iter

POLY_50K_1fs_5000iter 
POLY_50K_5fs_5000iter 
POLY_50K_10fs_5000iter 
POLY_50K_15fs_5000iter 
POLY_50K_16fs_5000iter 
POLY_50K_17fs_5000iter 
POLY_50K_18fs_5000iter 
POLY_50K_19fs_5000iter 
POLY_50K_20fs_5000iter 
POLY_50K_21fs_5000iter 
POLY_50K_22fs_5000iter 
POLY_50K_23fs_5000iter 
POLY_50K_24fs_5000iter 
POLY_50K_25fs_5000iter

25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1

noPOLY_500K_25fs_5000iter
noPOLY_500K_24fs_5000iter
noPOLY_500K_23fs_5000iter
noPOLY_500K_22fs_5000iter
noPOLY_500K_21fs_5000iter
noPOLY_500K_20fs_5000iter
noPOLY_500K_19fs_5000iter
noPOLY_500K_18fs_5000iter
noPOLY_500K_17fs_5000iter
noPOLY_500K_16fs_5000iter
noPOLY_500K_15fs_5000iter
noPOLY_500K_14fs_5000iter
noPOLY_500K_13fs_5000iter
noPOLY_500K_12fs_5000iter
noPOLY_500K_11fs_5000iter
noPOLY_500K_10fs_5000iter
noPOLY_500K_9fs_5000iter
noPOLY_500K_8fs_5000iter
noPOLY_500K_7fs_5000iter
noPOLY_500K_6fs_5000iter
noPOLY_500K_5fs_5000iter
noPOLY_500K_4fs_5000iter
noPOLY_500K_3fs_5000iter
noPOLY_500K_2fs_5000iter
noPOLY_500K_1fs_5000iter

POLY_500K_25fs_5000iter
POLY_500K_24fs_5000iter
POLY_500K_23fs_5000iter
POLY_500K_22fs_5000iter
POLY_500K_21fs_5000iter
POLY_500K_20fs_5000iter
POLY_500K_19fs_5000iter
POLY_500K_18fs_5000iter
POLY_500K_17fs_5000iter
POLY_500K_16fs_5000iter
POLY_500K_15fs_5000iter
POLY_500K_14fs_5000iter
POLY_500K_13fs_5000iter
POLY_500K_12fs_5000iter
POLY_500K_11fs_5000iter
POLY_500K_10fs_5000iter
POLY_500K_9fs_5000iter
POLY_500K_8fs_5000iter
POLY_500K_7fs_5000iter
POLY_500K_6fs_5000iter
POLY_500K_5fs_5000iter
POLY_500K_4fs_5000iter
POLY_500K_3fs_5000iter
POLY_500K_2fs_5000iter
POLY_500K_1fs_5000iter

1, 2, 3, 4, 5, 6

POLY_1000K_1fs_5000iter
POLY_1000K_2fs_5000iter
POLY_1000K_3fs_5000iter
POLY_1000K_4fs_5000iter
POLY_1000K_5fs_5000iter
POLY_1000K_6fs_5000iter

Comments:

When you plug dt = 1 fs at 50K, I observe smooth oscillations and not scattered as per higher dt values.
This seems to happen without the junction, with the junction the behaviour is much different.

For low dt, in the presence of the POLY junction, the energy seems to have two modes of oscillations. One
at high and one at low frequency, it should be interesting to study its frequency spectrum...